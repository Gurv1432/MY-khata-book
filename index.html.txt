import { useState, useEffect } from "react";
import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { motion } from "framer-motion";

// ðŸ”¥ Firebase
import { initializeApp } from "firebase/app";
import {
  getFirestore,
  collection,
  addDoc,
  doc,
  getDocs,
  onSnapshot,
  updateDoc,
  query,
  where,
} from "firebase/firestore";
import { getStorage, ref, uploadBytes, getDownloadURL } from "firebase/storage";

// âœ… YOUR FIREBASE CONFIG
const firebaseConfig = {
  apiKey: "AIzaSyDY8dXZzCHITz7JBfTiWacI72RJvbvD3U8",
  authDomain: "my-khata-book-23413.firebaseapp.com",
  projectId: "my-khata-book-23413",
  storageBucket: "my-khata-book-23413.firebasestorage.app",
  messagingSenderId: "459661864450",
  appId: "1:459661864450:web:9b9da51633c8238023411b",
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const storage = getStorage(app);

export default function KhataBookApp() {
  const [users, setUsers] = useState([]);
  const [currentUser, setCurrentUser] = useState(null);
  const [view, setView] = useState("login"); // login | signup | app | edit

  const [name, setName] = useState("");
  const [phone, setPhone] = useState("");
  const [loginId, setLoginId] = useState("");
  const [photoFile, setPhotoFile] = useState(null);
  const [connectCode, setConnectCode] = useState("");

  const [selectedLedger, setSelectedLedger] = useState(null);
  const [amount, setAmount] = useState("");
  const [date, setDate] = useState("");
  const [entryType, setEntryType] = useState("given");

  const generateCode = () => "U" + Math.random().toString(36).substring(2, 8).toUpperCase();

  // ðŸ”„ Realtime users sync
  useEffect(() => {
    const unsub = onSnapshot(collection(db, "users"), (snapshot) => {
      setUsers(snapshot.docs.map((d) => ({ id: d.id, ...d.data() })));
    });
    return () => unsub();
  }, []);

  // ðŸ‘¤ Signup
  const createUser = async () => {
    if (!name || !phone) return alert("Enter details");

    const code = generateCode();

    let photoURL = null;
    if (photoFile) {
      const storageRef = ref(storage, `profiles/${Date.now()}`);
      await uploadBytes(storageRef, photoFile);
      photoURL = await getDownloadURL(storageRef);
    }

    await addDoc(collection(db, "users"), {
      name,
      phone,
      code,
      photo: photoURL,
      requests: [],
      ledgers: {},
      locked: false,
    });

    setName("");
    setPhone("");
    setPhotoFile(null);
    setView("login");
  };

  // ðŸ” Login via Code OR Phone
  const loginUser = async () => {
    if (!loginId) return alert("Enter Code / Phone");

    const q = query(
      collection(db, "users"),
      where("code", "==", loginId)
    );

    const snap = await getDocs(q);

    if (!snap.empty) {
      setCurrentUser({ id: snap.docs[0].id, ...snap.docs[0].data() });
      setView("app");
      return;
    }

    const q2 = query(
      collection(db, "users"),
      where("phone", "==", loginId)
    );

    const snap2 = await getDocs(q2);

    if (!snap2.empty) {
      setCurrentUser({ id: snap2.docs[0].id, ...snap2.docs[0].data() });
      setView("app");
      return;
    }

    alert("User not found");
  };

  // ðŸ” Refresh current user realtime
  useEffect(() => {
    if (!currentUser) return;

    const unsub = onSnapshot(doc(db, "users", currentUser.id), (d) => {
      setCurrentUser({ id: d.id, ...d.data() });
    });

    return () => unsub();
  }, [currentUser?.id]);

  // ðŸ¤ Send request via code
  const sendRequest = async () => {
    const target = users.find((u) => u.code === connectCode);
    if (!target) return alert("User not found");

    const targetRef = doc(db, "users", target.id);

    await updateDoc(targetRef, {
      requests: [...(target.requests || []), currentUser.code],
    });

    setConnectCode("");
  };

  // âœ… Accept request
  const acceptRequest = async (senderCode) => {
    const sender = users.find((u) => u.code === senderCode);
    const ledgerId = [senderCode, currentUser.code].sort().join("_");

    const currentRef = doc(db, "users", currentUser.id);
    const senderRef = doc(db, "users", sender.id);

    await updateDoc(currentRef, {
      requests: currentUser.requests.filter((r) => r !== senderCode),
      [`ledgers.${ledgerId}`]: { role: "viewer", entries: [] },
    });

    await updateDoc(senderRef, {
      [`ledgers.${ledgerId}`]: { role: "editor", entries: [] },
    });
  };

  // âž• Add ledger entry (editor only)
  const addEntry = async () => {
    if (!amount || !date) return alert("Fill details");

    const ledger = currentUser.ledgers[selectedLedger];
    if (ledger.role !== "editor") return alert("Viewer cannot edit");

    const entry = { amount: Number(amount), date, type: entryType };

    const updates = {};
    users.forEach((u) => {
      if (u.ledgers?.[selectedLedger]) {
        updates[u.id] = u;
      }
    });

    for (let uid in updates) {
      const refDoc = doc(db, "users", uid);
      const entries = updates[uid].ledgers[selectedLedger].entries || [];

      await updateDoc(refDoc, {
        [`ledgers.${selectedLedger}.entries`]: [...entries, entry],
      });
    }

    setAmount("");
    setDate("");
  };

  const calculateBalance = (ledgerId) => {
    const ledger = currentUser.ledgers[ledgerId];
    if (!ledger) return 0;

    return (ledger.entries || []).reduce(
      (bal, e) => (e.type === "given" ? bal + e.amount : bal - e.amount),
      0
    );
  };

  // ðŸ’° Settlement (editor only)
  const settleLedger = async (ledgerId) => {
    const ledger = currentUser.ledgers[ledgerId];
    if (ledger.role !== "editor") return alert("Only editor can settle");

    const balance = calculateBalance(ledgerId);
    const entry = {
      amount: Math.abs(balance),
      date: new Date().toISOString().substring(0, 10),
      type: balance > 0 ? "taken" : "given",
      settlement: true,
    };

    const updates = {};
    users.forEach((u) => {
      if (u.ledgers?.[ledgerId]) updates[u.id] = u;
    });

    for (let uid in updates) {
      const refDoc = doc(db, "users", uid);
      const entries = updates[uid].ledgers[ledgerId].entries || [];

      await updateDoc(refDoc, {
        [`ledgers.${ledgerId}.entries`]: [...entries, entry],
      });
    }
  };

  // ðŸ“„ PDF Export
  const exportPDF = async (ledgerId) => {
    const ledger = currentUser.ledgers[ledgerId];
    const rows = (ledger.entries || [])
      .map((e) => `${e.date}  |  â‚¹ ${e.amount}  |  ${e.type}${e.settlement ? " (SETTLED)" : ""}`)
      .join("
");

    const blob = new Blob([
      `Ledger Statement

User: ${currentUser.name}
Ledger: ${ledgerId}

${rows}

Balance: â‚¹ ${calculateBalance(ledgerId)}`
    ], { type: "application/pdf" });

    const url = URL.createObjectURL(blob);
    window.open(url);
  };

  // ðŸ“Š Excel Export (CSV)
  const exportExcel = (ledgerId) => {
    const ledger = currentUser.ledgers[ledgerId];
    const rows = (ledger.entries || []).map((e) =>
      `${e.date},${e.amount},${e.type}${e.settlement ? ",SETTLEMENT" : ""}`
    );

    const csvContent = "Date,Amount,Type
" + rows.join("
");
    const blob = new Blob([csvContent], { type: "text/csv" });
    const url = URL.createObjectURL(blob);

    const a = document.createElement("a");
    a.href = url;
    a.download = `ledger_${ledgerId}.csv`;
    a.click();
  };

  // ðŸ”” Simple Reminder Logic
  const getReminderMessage = (ledgerId) => {
    const balance = calculateBalance(ledgerId);
    if (balance === 0) return "All settled âœ…";
    if (balance > 0) return `You will get â‚¹ ${balance}`;
    return `You need to pay â‚¹ ${Math.abs(balance)}`;
  }; = (ledgerId) => {
    const ledger = currentUser.ledgers[ledgerId];
    if (!ledger) return 0;

    return (ledger.entries || []).reduce(
      (bal, e) => (e.type === "given" ? bal + e.amount : bal - e.amount),
      0
    );
  };

  // ðŸ–¼ Profile edit (one-time lock)
  const saveProfileEdit = async () => {
    if (currentUser.locked) return alert("Profile locked");

    let photoURL = currentUser.photo;

    if (photoFile) {
      const storageRef = ref(storage, `profiles/${Date.now()}`);
      await uploadBytes(storageRef, photoFile);
      photoURL = await getDownloadURL(storageRef);
    }

    const userRef = doc(db, "users", currentUser.id);

    await updateDoc(userRef, {
      name,
      photo: photoURL,
      locked: true,
    });

    setView("app");
  };

  // ---------------- UI ----------------

  if (view === "signup") {
    return (
      <div className="min-h-screen bg-black text-white p-4 max-w-sm mx-auto space-y-4">
        <h1 className="text-2xl font-bold text-center">Create Account</h1>

        <Card className="bg-zinc-900">
          <CardContent className="p-4 space-y-3">
            <Input placeholder="Name" value={name} onChange={(e) => setName(e.target.value)} />
            <Input placeholder="Phone" value={phone} onChange={(e) => setPhone(e.target.value)} />
            <Input type="file" accept="image/*" onChange={(e) => setPhotoFile(e.target.files[0])} />
            <Button className="w-full" onClick={createUser}>Signup</Button>
            <Button variant="outline" onClick={() => setView("login")}>Back</Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (!currentUser) {
    return (
      <div className="min-h-screen bg-black text-white p-4 max-w-sm mx-auto space-y-4">
        <h1 className="text-2xl font-bold text-center">Khata RT</h1>

        <Card className="bg-zinc-900">
          <CardContent className="p-4 space-y-3">
            <Input placeholder="Code OR Phone" value={loginId} onChange={(e) => setLoginId(e.target.value)} />
            <Button className="w-full" onClick={loginUser}>Login</Button>
            <Button variant="outline" onClick={() => setView("signup")}>Create Account</Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  if (view === "edit") {
    return (
      <div className="min-h-screen bg-black text-white p-4 max-w-sm mx-auto space-y-4">
        <h1 className="text-xl font-bold">Edit Profile</h1>

        <Card className="bg-zinc-900">
          <CardContent className="p-4 space-y-3">
            <Input value={name} onChange={(e) => setName(e.target.value)} />
            <Input type="file" accept="image/*" onChange={(e) => setPhotoFile(e.target.files[0])} />
            <Button onClick={saveProfileEdit}>Save (One Time)</Button>
            <Button variant="outline" onClick={() => setView("app")}>Cancel</Button>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-black text-white p-4 max-w-sm mx-auto space-y-3">
      <div className="flex justify-between">
        <div className="flex gap-2 items-center">
          {currentUser.photo && (
            <img src={currentUser.photo} className="w-10 h-10 rounded-full" />
          )}
          <div>
            <h1 className="font-bold">{currentUser.name}</h1>
            <p className="text-xs text-zinc-400">{currentUser.code}</p>
          </div>
        </div>
        <Button size="sm" variant="outline" onClick={() => {
          setName(currentUser.name);
          setView("edit");
        }}>Edit</Button>
      </div>

      <Card className="bg-zinc-900">
        <CardContent className="p-3 flex gap-2">
          <Input placeholder="Enter user code" value={connectCode} onChange={(e) => setConnectCode(e.target.value)} />
          <Button onClick={sendRequest}>Add</Button>
        </CardContent>
      </Card>

      <Card className="bg-zinc-900">
        <CardContent className="p-3">
          <h2 className="font-semibold">Accounts</h2>
          <div className="space-y-2 mt-2">
            {Object.keys(currentUser.ledgers || {}).map((ledgerId) => (
              <Button key={ledgerId} variant="outline" className="w-full justify-between" onClick={() => setSelectedLedger(ledgerId)}>
                <span>{ledgerId}</span>
                <span>â‚¹ {calculateBalance(ledgerId)}</span>
              </Button>
            ))}
          </div>
        </CardContent>
      </Card>

      {selectedLedger && (
        <Card className="bg-zinc-900">
          <CardContent className="p-3 space-y-2">
            <h2 className="font-semibold">Ledger</h2>

            {currentUser.ledgers[selectedLedger].role === "editor" && (
              <>
                <Input type="date" value={date} onChange={(e) => setDate(e.target.value)} />
                <Input placeholder="Amount" value={amount} onChange={(e) => setAmount(e.target.value)} />
                <select className="bg-black border border-zinc-700 rounded-xl p-2" value={entryType} onChange={(e) => setEntryType(e.target.value)}>
                  <option value="given">Given</option>
                  <option value="taken">Taken</option>
                </select>
                <Button onClick={addEntry}>Add Entry</Button>
              </>
            )}

            {(currentUser.ledgers[selectedLedger].entries || []).map((e, i) => (
              <div key={i} className="flex justify-between text-sm border-b border-zinc-800 pb-1">
                <span>{e.date}</span>
                <span>â‚¹ {e.amount}</span>
                <span className={e.type === "given" ? "text-green-400" : "text-red-400"}>{e.type}</span>
              </div>
            ))}

            <div className="text-right font-bold">Balance â‚¹ {calculateBalance(selectedLedger)}</div>

            <div className="text-xs text-zinc-400 text-right">
              {getReminderMessage(selectedLedger)}
            </div>

            {currentUser.ledgers[selectedLedger].role === "editor" && (
              <div className="grid grid-cols-3 gap-2 pt-2">
                <Button variant="outline" onClick={() => settleLedger(selectedLedger)}>Settle</Button>
                <Button variant="outline" onClick={() => exportPDF(selectedLedger)}>PDF</Button>
                <Button variant="outline" onClick={() => exportExcel(selectedLedger)}>Excel</Button>
              </div>
            )} â‚¹ {calculateBalance(selectedLedger)}</div>
          </CardContent>
        </Card>
      )}
    </div>
  );
}
